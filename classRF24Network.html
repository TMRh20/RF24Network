<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Newly Optimized RF24Network Layer: RF24Network Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Newly Optimized RF24Network Layer
   &#160;<span id="projectnumber">1.0.15</span>
   </div>
   <div id="projectbrief">2020 - Optimized RF24 Network Layer for NRF24L01 radios</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classRF24Network-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RF24Network Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="RF24Network_8h_source.html">RF24Network.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Primary Interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are the main methods you need to operate the network </p>
</div></td></tr>
<tr class="memitem:a814229a5a4e8e30f88a4bdce05807e50"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a814229a5a4e8e30f88a4bdce05807e50">RF24Network</a> (RF24 &amp;_radio)</td></tr>
<tr class="separator:a814229a5a4e8e30f88a4bdce05807e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6a74b55514a26e95e20eaa6a093a0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#aad6a74b55514a26e95e20eaa6a093a0b">begin</a> (uint16_t _node_address)</td></tr>
<tr class="separator:aad6a74b55514a26e95e20eaa6a093a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59983f89b09d17d7d9b0581f658a41c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#ad59983f89b09d17d7d9b0581f658a41c">update</a> (void)</td></tr>
<tr class="separator:ad59983f89b09d17d7d9b0581f658a41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e111e70bb7b95d885983ce92c89159e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a0e111e70bb7b95d885983ce92c89159e">available</a> (void)</td></tr>
<tr class="separator:a0e111e70bb7b95d885983ce92c89159e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac371cf064c23d181c5dd56f528bd08"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#abac371cf064c23d181c5dd56f528bd08">peek</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header)</td></tr>
<tr class="separator:abac371cf064c23d181c5dd56f528bd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774fa1032ace9de23d1951915fa1a501"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a774fa1032ace9de23d1951915fa1a501">peek</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header, void *message, uint16_t maxlen)</td></tr>
<tr class="separator:a774fa1032ace9de23d1951915fa1a501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1369794c26042ebe9e3874adaec371a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#ac1369794c26042ebe9e3874adaec371a">read</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header, void *message, uint16_t maxlen)</td></tr>
<tr class="separator:ac1369794c26042ebe9e3874adaec371a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e9571bb3d2c20d00955b8f5c15b541"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#ac8e9571bb3d2c20d00955b8f5c15b541">write</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header, const void *message, uint16_t len)</td></tr>
<tr class="separator:ac8e9571bb3d2c20d00955b8f5c15b541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Advanced Operation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Timeout for routed payloads</p>
<p>For advanced operation of the network </p>
</div></td></tr>
<tr class="memitem:acb84d7556df00c933208ecf44b227a4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#acb84d7556df00c933208ecf44b227a4f">failures</a> (uint32_t *_fails, uint32_t *_ok)</td></tr>
<tr class="separator:acb84d7556df00c933208ecf44b227a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e19015dbf5073a8401e0fe71f68848"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a25e19015dbf5073a8401e0fe71f68848">multicast</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header, const void *message, uint16_t len, uint8_t level)</td></tr>
<tr class="separator:a25e19015dbf5073a8401e0fe71f68848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d99643014071fef706c0320c8011648"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a3d99643014071fef706c0320c8011648">write</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header, const void *message, uint16_t len, uint16_t writeDirect)</td></tr>
<tr class="separator:a3d99643014071fef706c0320c8011648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3e7809ffc7ff48579811d2e063142a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#acc3e7809ffc7ff48579811d2e063142a">sleepNode</a> (unsigned int cycles, int interruptPin, uint8_t INTERRUPT_MODE=0)</td></tr>
<tr class="separator:acc3e7809ffc7ff48579811d2e063142a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6919435695051d522dfcce4e8395f5e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#aa6919435695051d522dfcce4e8395f5e">parent</a> () const</td></tr>
<tr class="separator:aa6919435695051d522dfcce4e8395f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a11edb3860f4a0e3808bccad36a5dc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#aa4a11edb3860f4a0e3808bccad36a5dc">addressOfPipe</a> (uint16_t node, uint8_t pipeNo)</td></tr>
<tr class="separator:aa4a11edb3860f4a0e3808bccad36a5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41da035bd7f469ea4364a06ab4efd1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#ab41da035bd7f469ea4364a06ab4efd1b">is_valid_address</a> (uint16_t node)</td></tr>
<tr class="separator:ab41da035bd7f469ea4364a06ab4efd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Deprecated</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Maintained for backwards compatibility </p>
</div></td></tr>
<tr class="memitem:abf0da46b2e78b2010171c9f20cba8bae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#abf0da46b2e78b2010171c9f20cba8bae">begin</a> (uint8_t _channel, uint16_t _node_address)</td></tr>
<tr class="separator:abf0da46b2e78b2010171c9f20cba8bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Advanced Configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc70ec5b31b31ecef0efd3ea40e33909f"></a>For advanced configuration of the network </p>
</td></tr>
<tr class="memitem:add7408ca2b2f9ab15331ba77a747f7bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#add7408ca2b2f9ab15331ba77a747f7bb">multicastRelay</a></td></tr>
<tr class="separator:add7408ca2b2f9ab15331ba77a747f7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8838b42717e7c9da37213b020db1f88c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a8838b42717e7c9da37213b020db1f88c">txTimeout</a></td></tr>
<tr class="separator:a8838b42717e7c9da37213b020db1f88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657fd03730b6c9084cc440b4fe0177c3"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a657fd03730b6c9084cc440b4fe0177c3">routeTimeout</a></td></tr>
<tr class="separator:a657fd03730b6c9084cc440b4fe0177c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb7c61eee75d708a4ba20bb1caec54f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a4fb7c61eee75d708a4ba20bb1caec54f">multicastLevel</a> (uint8_t level)</td></tr>
<tr class="separator:a4fb7c61eee75d708a4ba20bb1caec54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb09129760ac9b171833af3055b2b6f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#acb09129760ac9b171833af3055b2b6f5">setup_watchdog</a> (uint8_t prescalar)</td></tr>
<tr class="separator:acb09129760ac9b171833af3055b2b6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">External Applications/Systems</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpa44565bba507e198594663bd302b9223"></a>Interface for External Applications and Systems ( RF24Mesh, RF24Ethernet ) </p>
</td></tr>
<tr class="memitem:aa06f1fdd0fd986d427c2c5193b47b212"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#aa06f1fdd0fd986d427c2c5193b47b212">frame_buffer</a> [<a class="el" href="RF24Network_8h.html#ad15d35a0d29a9dbf9324e3859ce3b008">MAX_FRAME_SIZE</a>]</td></tr>
<tr class="separator:aa06f1fdd0fd986d427c2c5193b47b212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c994c5fdcb2173b187c52b641aaeae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRF24NetworkFrame.html">RF24NetworkFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a1c994c5fdcb2173b187c52b641aaeae0">frag_ptr</a></td></tr>
<tr class="separator:a1c994c5fdcb2173b187c52b641aaeae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6b1d5c0fa3d982425f7a1f4fb48d13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#afb6b1d5c0fa3d982425f7a1f4fb48d13">returnSysMsgs</a></td></tr>
<tr class="separator:afb6b1d5c0fa3d982425f7a1f4fb48d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476806538919b167465181ab872e0cad"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a476806538919b167465181ab872e0cad">networkFlags</a></td></tr>
<tr class="separator:a476806538919b167465181ab872e0cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>2014-2020 - Optimized Network Layer for RF24 Radios</p>
<p>This class implements an OSI Network Layer using nRF24L01(+) radios driven by RF24 library. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Network_Ping_8ino-example.html#_a0">Network_Ping.ino</a>, <a class="el" href="Network_Ping_Sleep_8ino-example.html#_a0">Network_Ping_Sleep.ino</a>, <a class="el" href="Network_Priority_RX_8ino-example.html#_a0">Network_Priority_RX.ino</a>, <a class="el" href="Network_Priority_TX_8ino-example.html#_a0">Network_Priority_TX.ino</a>, <a class="el" href="helloworld_rx_8ino-example.html#_a0">helloworld_rx.ino</a>, <a class="el" href="helloworld_rx_advanced_8ino-example.html#_a0">helloworld_rx_advanced.ino</a>, <a class="el" href="helloworld_tx_8ino-example.html#_a0">helloworld_tx.ino</a>, and <a class="el" href="helloworld_tx_advanced_8ino-example.html#_a0">helloworld_tx_advanced.ino</a>.</dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a814229a5a4e8e30f88a4bdce05807e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814229a5a4e8e30f88a4bdce05807e50">&#9670;&nbsp;</a></span>RF24Network()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF24Network::RF24Network </td>
          <td>(</td>
          <td class="paramtype">RF24 &amp;&#160;</td>
          <td class="paramname"><em>_radio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct the network</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_radio</td><td>The underlying radio driver instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aad6a74b55514a26e95e20eaa6a093a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6a74b55514a26e95e20eaa6a093a0b">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::begin </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>_node_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bring up the network using the current radio frequency/channel. Calling begin brings up the network, and configures the address, which designates the location of the node within <a class="el" href="classRF24Network.html">RF24Network</a> topology. </p><dl class="section note"><dt>Note</dt><dd>Node addresses are specified in Octal format, see <a href="Addressing.html">RF24Network Addressing</a> for more information. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Be sure to 'begin' the radio first.</dd></dl>
<p><b>Example 1:</b> Begin on current radio channel with address 0 (master node) </p><div class="fragment"><div class="line">network.begin(00);</div>
</div><!-- fragment --><p> <b>Example 2:</b> Begin with address 01 (child of master) </p><div class="fragment"><div class="line">network.begin(01);</div>
</div><!-- fragment --><p> <b>Example 3:</b> Begin with address 011 (child of 01, grandchild of master) </p><div class="fragment"><div class="line">network.begin(011);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24Network.html#abf0da46b2e78b2010171c9f20cba8bae">begin(uint8_t _channel, uint16_t _node_address)</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_node_address</td><td>The logical address of this node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad59983f89b09d17d7d9b0581f658a41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59983f89b09d17d7d9b0581f658a41c">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24Network::update </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Main layer loop</p>
<p>This function must be called regularly to keep the layer going. This is where payloads are re-routed, received, and all the action happens.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the type of the last received payload. </dd></dl>

</div>
</div>
<a id="a0e111e70bb7b95d885983ce92c89159e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e111e70bb7b95d885983ce92c89159e">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether there is a message available for this node</p>
<dl class="section return"><dt>Returns</dt><dd>Whether there is a message available for this node </dd></dl>

</div>
</div>
<a id="abac371cf064c23d181c5dd56f528bd08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac371cf064c23d181c5dd56f528bd08">&#9670;&nbsp;</a></span>peek() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t RF24Network::peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the next available header</p>
<p>Reads the next available header without advancing to the next incoming message. Useful for doing a switch on the message type</p>
<p>If there is no message available, the header is not touched</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">header</td><td>The header (envelope) of the next message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a774fa1032ace9de23d1951915fa1a501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774fa1032ace9de23d1951915fa1a501">&#9670;&nbsp;</a></span>peek() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the next available payload</p>
<p>Reads the next available payload without advancing to the next incoming message. Useful for doing a transparent packet manipulation layer on top of <a class="el" href="classRF24Network.html">RF24Network</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">header</td><td>The header (envelope) of this message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message</td><td>Pointer to memory where the message should be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxlen</td><td>Amount of bytes to copy to message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1369794c26042ebe9e3874adaec371a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1369794c26042ebe9e3874adaec371a">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t RF24Network::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a message</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (network.available()) {</div>
<div class="line">  <a class="code" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> header;</div>
<div class="line">  uint32_t time;</div>
<div class="line">  network.peek(header);</div>
<div class="line">  <span class="keywordflow">if</span> (header.<a class="code" href="structRF24NetworkHeader.html#ac99ab14e561670f4445d1fea7775e2db">type</a> == <span class="charliteral">&#39;T&#39;</span>) {</div>
<div class="line">    network.read(header, &amp;time, <span class="keyword">sizeof</span>(time));</div>
<div class="line">    Serial.print(<span class="stringliteral">&quot;Got time: &quot;</span>);</div>
<div class="line">    Serial.println(time);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="astructRF24NetworkHeader_html"><div class="ttname"><a href="structRF24NetworkHeader.html">RF24NetworkHeader</a></div><div class="ttdef"><b>Definition:</b> RF24Network.h:187</div></div>
<div class="ttc" id="astructRF24NetworkHeader_html_ac99ab14e561670f4445d1fea7775e2db"><div class="ttname"><a href="structRF24NetworkHeader.html#ac99ab14e561670f4445d1fea7775e2db">RF24NetworkHeader::type</a></div><div class="ttdeci">unsigned char type</div><div class="ttdef"><b>Definition:</b> RF24Network.h:197</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">header</td><td>The header (envelope) of this message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message</td><td>Pointer to memory where the message should be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxlen</td><td>The largest message size which can be held in <code>message</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes copied into <code>message</code> </dd></dl>

</div>
</div>
<a id="ac8e9571bb3d2c20d00955b8f5c15b541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e9571bb3d2c20d00955b8f5c15b541">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a message</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classRF24Network.html">RF24Network</a> now supports fragmentation for very long messages, send as normal. Fragmentation may need to be enabled or configured by editing the <a class="el" href="RF24Network__config_8h.html">RF24Network_config.h</a> file. Default max payload size is 120 bytes.</dd></dl>
<div class="fragment"><div class="line">uint32_t time = millis();</div>
<div class="line">uint16_t to = 00; <span class="comment">// Send to master</span></div>
<div class="line"><a class="code" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> header(to, <span class="charliteral">&#39;T&#39;</span>); <span class="comment">// Send header type &#39;T&#39;</span></div>
<div class="line">network.write(header, &amp;time, <span class="keyword">sizeof</span>(time));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">header</td><td>The header (envelope) of this message. The critical thing to fill in is the <code>to_node</code> field so we know where to send the message. It is then updated with the details of the actual header sent. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">message</td><td>Pointer to memory where the message is located </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>The size of the message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the message was successfully received </dd></dl>

</div>
</div>
<a id="a4fb7c61eee75d708a4ba20bb1caec54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb7c61eee75d708a4ba20bb1caec54f">&#9670;&nbsp;</a></span>multicastLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::multicastLevel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default, multicast addresses are divided into levels.</p>
<p>Nodes 1-5 share a multicast address, nodes n1-n5 share a multicast address, and nodes n11-n55 share a multicast address.<br  />
</p>
<p>This option is used to override the defaults, and create custom multicast groups that all share a single address. <br  />
 The level should be specified in decimal format 1-6 <br  />
 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24Network.html#add7408ca2b2f9ab15331ba77a747f7bb">multicastRelay</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Levels 1 to 6 are available. All nodes at the same level will receive the same messages if in range. Messages will be routed in order of level, low to high by default, with the master node (00) at multicast Level 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb09129760ac9b171833af3055b2b6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb09129760ac9b171833af3055b2b6f5">&#9670;&nbsp;</a></span>setup_watchdog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::setup_watchdog </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prescalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set up the watchdog timer for sleep mode using the number 0 through 10 to represent the following time periods:<br  />
 wdt_16ms = 0, wdt_32ms, wdt_64ms, wdt_128ms, wdt_250ms, wdt_500ms, wdt_1s, wdt_2s, wdt_4s, wdt_8s </p><div class="fragment"><div class="line"><a class="code" href="classRF24Network.html#acb09129760ac9b171833af3055b2b6f5">setup_watchdog</a>(7);   <span class="comment">// Sets the WDT to trigger every second</span></div>
<div class="ttc" id="aclassRF24Network_html_acb09129760ac9b171833af3055b2b6f5"><div class="ttname"><a href="classRF24Network.html#acb09129760ac9b171833af3055b2b6f5">RF24Network::setup_watchdog</a></div><div class="ttdeci">void setup_watchdog(uint8_t prescalar)</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prescalar</td><td>The WDT prescaler to define how often the node will wake up. When defining sleep mode cycles, this time period is 1 cycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb84d7556df00c933208ecf44b227a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb84d7556df00c933208ecf44b227a4f">&#9670;&nbsp;</a></span>failures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::failures </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>_fails</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>_ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of failures and successes for all transmitted payloads, routed or sent directly </p><dl class="section note"><dt>Note</dt><dd>This needs to be enabled via <code>#define ENABLE_NETWORK_STATS</code> in <a class="el" href="RF24Network__config_8h.html">RF24Network_config.h</a></dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> fails, success;</div>
<div class="line">network.failures(&amp;fails, &amp;success);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a25e19015dbf5073a8401e0fe71f68848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e19015dbf5073a8401e0fe71f68848">&#9670;&nbsp;</a></span>multicast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::multicast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a multicast message to multiple nodes at once Allows messages to be rapidly broadcast through the network</p>
<p>Multicasting is arranged in levels, with all nodes on the same level listening to the same address Levels are assigned by network level ie: nodes 01-05: Level 1, nodes 011-055: Level 2 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24Network.html#a4fb7c61eee75d708a4ba20bb1caec54f">multicastLevel</a> </dd>
<dd>
<a class="el" href="classRF24Network.html#add7408ca2b2f9ab15331ba77a747f7bb">multicastRelay</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>reference to the <a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> object used for this <code>message</code> </td></tr>
    <tr><td class="paramname">message</td><td>Pointer to memory where the message is located </td></tr>
    <tr><td class="paramname">len</td><td>The size of the message </td></tr>
    <tr><td class="paramname">level</td><td>Multicast level to broadcast to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the message was successfully sent </dd></dl>

</div>
</div>
<a id="a3d99643014071fef706c0320c8011648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d99643014071fef706c0320c8011648">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>writeDirect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a direct (unicast) payload. This allows routing or sending messages outside of the usual routing paths. The same as write, but a physical address is specified as the last option. The payload will be written to the physical address, and routed as necessary by the recipient </p>

</div>
</div>
<a id="acc3e7809ffc7ff48579811d2e063142a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3e7809ffc7ff48579811d2e063142a">&#9670;&nbsp;</a></span>sleepNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::sleepNode </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interruptPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>INTERRUPT_MODE</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sleep this node - For AVR devices only </p><dl class="section note"><dt>Note</dt><dd>NEW - Nodes can now be slept while the radio is not actively transmitting. This must be manually enabled by uncommenting the <code>#define ENABLE_SLEEP_MODE</code> in <a class="el" href="RF24Network__config_8h.html">RF24Network_config.h</a> </dd>
<dd>
Setting the interruptPin to 255 will disable interrupt wake-ups </dd>
<dd>
The watchdog timer should be configured in setup() if using sleep mode. This function will sleep the node, with the radio still active in receive mode.</dd></dl>
<p>The node can be awoken in two ways, both of which can be enabled simultaneously:</p><ol type="1">
<li>An interrupt - usually triggered by the radio receiving a payload. Must use pin 2 (interrupt 0) or 3 (interrupt 1) on Uno, Nano, etc.</li>
<li>The watchdog timer waking the MCU after a designated period of time, can also be used instead of delays to control transmission intervals. <div class="fragment"><div class="line"><span class="keywordflow">if</span>(!network.available()){ network.sleepNode(1,0); }  <span class="comment">//Sleeps the node for 1 second or a payload is received</span></div>
<div class="line"> </div>
<div class="line">Other options:</div>
<div class="line">network.sleepNode(0,0);         <span class="comment">// Sleep this node for the designated time period, or a payload is received.</span></div>
<div class="line">network.sleepNode(1,255);       <span class="comment">// Sleep this node for 1 cycle. Do not wake up until then, even if a payload is received ( no interrupt )</span></div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24Network.html#acb09129760ac9b171833af3055b2b6f5">setup_watchdog()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycles</td><td>The node will sleep in cycles of 1s. Using 2 will sleep 2 WDT cycles, 3 sleeps 3WDT cycles... </td></tr>
    <tr><td class="paramname">interruptPin</td><td>The interrupt number to use (0,1) for pins two and three on Uno,Nano. More available on Mega etc. </td></tr>
    <tr><td class="paramname">INTERRUPT_MODE</td><td>an identifying number to indicate what type of state for which the <code>interrupt_pin</code> will be used to wake up the radio. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"><code>INTERRUPT_MODE</code>   </th><th class="markdownTableHeadCenter">type of state    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyCenter">LOW    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1   </td><td class="markdownTableBodyCenter">RISING    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">2   </td><td class="markdownTableBodyCenter">FALLING    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">3   </td><td class="markdownTableBodyCenter">CHANGE   </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sleepNode completed normally, after the specified number of cycles. False if sleep was interrupted </dd></dl>
</li>
</ol>

</div>
</div>
<a id="aa6919435695051d522dfcce4e8395f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6919435695051d522dfcce4e8395f5e">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t RF24Network::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This node's parent address</p>
<dl class="section return"><dt>Returns</dt><dd>This node's parent address, or -1 if this is the base </dd></dl>

</div>
</div>
<a id="aa4a11edb3860f4a0e3808bccad36a5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a11edb3860f4a0e3808bccad36a5dc">&#9670;&nbsp;</a></span>addressOfPipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t RF24Network::addressOfPipe </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipeNo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provided a node address and a pipe number, will return the <a class="el" href="classRF24Network.html">RF24Network</a> address of that child pipe for that node </p>

</div>
</div>
<a id="ab41da035bd7f469ea4364a06ab4efd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41da035bd7f469ea4364a06ab4efd1b">&#9670;&nbsp;</a></span>is_valid_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::is_valid_address </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Addresses are specified in octal: 011, 034 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if a supplied address is valid </dd></dl>

</div>
</div>
<a id="abf0da46b2e78b2010171c9f20cba8bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0da46b2e78b2010171c9f20cba8bae">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::begin </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>_node_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bring up the network on a specific radio frequency/channel. </p><dl class="section note"><dt>Note</dt><dd>Use radio.setChannel() to configure the radio channel</dd></dl>
<p><b>Example 1:</b> Begin on channel 90 with address 0 (master node) </p><div class="fragment"><div class="line">network.begin(90, 0);</div>
</div><!-- fragment --><p> <b>Example 2:</b> Begin on channel 90 with address 01 (child of master) </p><div class="fragment"><div class="line">network.begin(90, 01);</div>
</div><!-- fragment --><p> <b>Example 3:</b> Begin on channel 90 with address 011 (child of 01, grandchild of master) </p><div class="fragment"><div class="line">network.begin(90, 011);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_channel</td><td>The RF channel to operate on </td></tr>
    <tr><td class="paramname">_node_address</td><td>The logical address of this node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="add7408ca2b2f9ab15331ba77a747f7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7408ca2b2f9ab15331ba77a747f7bb">&#9670;&nbsp;</a></span>multicastRelay</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::multicastRelay</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enabling this will allow this node to automatically forward received multicast frames to the next highest multicast level. Duplicate frames are filtered out, so multiple forwarding nodes at the same level should not interfere. Forwarded payloads will also be received. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24Network.html#a4fb7c61eee75d708a4ba20bb1caec54f">multicastLevel</a> </dd></dl>

</div>
</div>
<a id="a8838b42717e7c9da37213b020db1f88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8838b42717e7c9da37213b020db1f88c">&#9670;&nbsp;</a></span>txTimeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RF24Network::txTimeout</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>: This value is automatically assigned based on the node address to reduce errors and increase throughput of the network.</dd></dl>
<p>Sets the timeout period for individual payloads in milliseconds at staggered intervals. Payloads will be retried automatically until success or timeout Set to 0 to use the normal auto retry period defined by radio.setRetries() </p>

</div>
</div>
<a id="a657fd03730b6c9084cc440b4fe0177c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657fd03730b6c9084cc440b4fe0177c3">&#9670;&nbsp;</a></span>routeTimeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t RF24Network::routeTimeout</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Network timeout value This only affects payloads that are routed by one or more nodes. This specifies how long to wait for an ack from across the network. Radios sending directly to their parent or children nodes do not utilize this value. </p>

</div>
</div>
<a id="aa06f1fdd0fd986d427c2c5193b47b212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06f1fdd0fd986d427c2c5193b47b212">&#9670;&nbsp;</a></span>frame_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24Network::frame_buffer[<a class="el" href="RF24Network_8h.html#ad15d35a0d29a9dbf9324e3859ce3b008">MAX_FRAME_SIZE</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The raw system frame buffer of received data. </p>

</div>
</div>
<a id="a1c994c5fdcb2173b187c52b641aaeae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c994c5fdcb2173b187c52b641aaeae0">&#9670;&nbsp;</a></span>frag_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRF24NetworkFrame.html">RF24NetworkFrame</a>* RF24Network::frag_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Linux</b> <br  />
 Data with a header type of EXTERNAL_DATA_TYPE will be loaded into a separate queue. The data can be accessed as follows: </p><div class="fragment"><div class="line"><a class="code" href="structRF24NetworkFrame.html">RF24NetworkFrame</a> f;</div>
<div class="line"><span class="keywordflow">while</span>(network.external_queue.size() &gt; 0) {</div>
<div class="line">  f = network.external_queue.front();</div>
<div class="line">  uint16_t dataSize = f.<a class="code" href="structRF24NetworkFrame.html#a6d44701fc5ef58ed6f674fde132bedff">message_size</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// read the frame message buffer</span></div>
<div class="line">  memcpy(&amp;myBuffer, &amp;f.<a class="code" href="structRF24NetworkFrame.html#a2ca805d90caa7aef8005fafd2c55fbc6">message_buffer</a>, dataSize);</div>
<div class="line">  network.external_queue.pop();</div>
<div class="line">}</div>
<div class="ttc" id="astructRF24NetworkFrame_html"><div class="ttname"><a href="structRF24NetworkFrame.html">RF24NetworkFrame</a></div><div class="ttdef"><b>Definition:</b> RF24Network.h:261</div></div>
<div class="ttc" id="astructRF24NetworkFrame_html_a2ca805d90caa7aef8005fafd2c55fbc6"><div class="ttname"><a href="structRF24NetworkFrame.html#a2ca805d90caa7aef8005fafd2c55fbc6">RF24NetworkFrame::message_buffer</a></div><div class="ttdeci">uint8_t * message_buffer</div><div class="ttdef"><b>Definition:</b> RF24Network.h:272</div></div>
<div class="ttc" id="astructRF24NetworkFrame_html_a6d44701fc5ef58ed6f674fde132bedff"><div class="ttname"><a href="structRF24NetworkFrame.html#a6d44701fc5ef58ed6f674fde132bedff">RF24NetworkFrame::message_size</a></div><div class="ttdeci">uint16_t message_size</div><div class="ttdef"><b>Definition:</b> RF24Network.h:263</div></div>
</div><!-- fragment --><p> <b>ARDUINO</b> <br  />
 The frag_ptr is only used with Arduino (not RPi/Linux) and is mainly used for external data systems like RF24Ethernet. When an EXTERNAL_DATA payload type is received, and returned from network.update(), the frag_ptr will always point to the starting memory location of the received frame. <br  />
This is used by external data systems (RF24Ethernet) to immediately copy the received data to a buffer, without using the user-cache.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structRF24NetworkFrame.html">RF24NetworkFrame</a></dd></dl>
<div class="fragment"><div class="line">uint8_t return_type = network.update();</div>
<div class="line"><span class="keywordflow">if</span>(return_type == <a class="code" href="group__DEFINED__TYPES.html#gac6bbd2772e776d10ca7c5f3c7eddf982">EXTERNAL_DATA_TYPE</a>) {</div>
<div class="line">    uint16_t size = network.frag_ptr-&gt;message_size;</div>
<div class="line">    memcpy(&amp;myDataBuffer, network.frag_ptr-&gt;message_buffer, network.frag_ptr-&gt;message_size);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__DEFINED__TYPES_html_gac6bbd2772e776d10ca7c5f3c7eddf982"><div class="ttname"><a href="group__DEFINED__TYPES.html#gac6bbd2772e776d10ca7c5f3c7eddf982">EXTERNAL_DATA_TYPE</a></div><div class="ttdeci">#define EXTERNAL_DATA_TYPE</div><div class="ttdef"><b>Definition:</b> RF24Network.h:93</div></div>
</div><!-- fragment --><p> Linux devices (defined as RF24_LINUX) currently cache all payload types, and do not utilize frag_ptr. </p>

</div>
</div>
<a id="afb6b1d5c0fa3d982425f7a1f4fb48d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6b1d5c0fa3d982425f7a1f4fb48d13">&#9670;&nbsp;</a></span>returnSysMsgs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::returnSysMsgs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable to determine whether <a class="el" href="classRF24Network.html#ad59983f89b09d17d7d9b0581f658a41c">update()</a> will return after the radio buffers have been emptied (DEFAULT), or whether to return immediately when (most) system types are received.</p>
<p>As an example, this is used with RF24Mesh to catch and handle system messages without loading them into the user cache.</p>
<p>The following reserved/system message types are handled automatically, and not returned.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">System Message Types <br  />
 (Not Returned)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">NETWORK_ADDR_RESPONSE    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">NETWORK_ACK    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">NETWORK_PING    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">NETWORK_POLL <br  />
(With multicast enabled)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">NETWORK_REQ_ADDRESS   </td></tr>
</table>

</div>
</div>
<a id="a476806538919b167465181ab872e0cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476806538919b167465181ab872e0cad">&#9670;&nbsp;</a></span>networkFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24Network::networkFlags</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Network Flags allow control of data flow</p>
<p>Incoming Blocking: If the network user-cache is full, lets radio cache fill up. Radio ACKs are not sent when radio internal cache is full.<br  />
 This behaviour may seem to result in more failed sends, but the payloads would have otherwise been dropped due to the cache being full.<br  />
</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">FLAGS   </th><th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FLAG_HOLD_INCOMING   </td><td class="markdownTableBodyNone">1(bit_1)   </td><td class="markdownTableBodyNone">INTERNAL: Set automatically when a fragmented payload will exceed the available cache    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FLAG_BYPASS_HOLDS   </td><td class="markdownTableBodyNone">2(bit_2)   </td><td class="markdownTableBodyNone">EXTERNAL: Can be used to prevent holds from blocking. Note: Holds are disabled &amp; re-enabled by RF24Mesh when renewing addresses. This will cause data loss if incoming data exceeds the available cache space    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FLAG_FAST_FRAG   </td><td class="markdownTableBodyNone">4(bit_3)   </td><td class="markdownTableBodyNone">INTERNAL: Replaces the fastFragTransfer variable, and allows for faster transfers between directly connected nodes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FLAG_NO_POLL   </td><td class="markdownTableBodyNone">8(bit_4)   </td><td class="markdownTableBodyNone">EXTERNAL/USER: Disables NETWORK_POLL responses on a node-by-node basis.   </td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 13 2021 01:08:19 for Newly Optimized RF24Network Layer by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
