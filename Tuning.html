<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Newly Optimized RF24Network Layer: Performance and Data Loss: Tuning the Network</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Newly Optimized RF24Network Layer
   &#160;<span id="projectnumber">v1.0.14</span>
   </div>
   <div id="projectbrief">2020 - Optimized RF24 Network Layer for NRF24L01 radios</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Performance and Data Loss: Tuning the Network </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Tips and examples for tuning the network and general operation.</p>
<div class="image">
<img src="topologyImage.jpg" alt="" width="75%" height="75%"/>
</div>
<h1><a class="anchor" id="General"></a>
Understanding Radio Communication and Topology</h1>
<p>When a transmission takes place from one radio module to another, the receiving radio will communicate back to the sender with an acknowledgement (ACK) packet, to indicate success. If the sender does not receive an ACK, the radio automatically engages in a series of timed retries, at set intervals. The radios use techniques like addressing and numbering of payloads to manage this, but it is all done automatically by the nrf chip, out of sight from the user.</p>
<p>When working over a radio network, some of these automated techniques can actually hinder data transmission to a degree. Retrying failed payloads over and over on a radio network can hinder communication for nearby nodes, or reduce throughput and errors on routing nodes.</p>
<p>Radios in this network are linked by <b>addresses</b> assigned to <b>pipes</b>. Each radio can listen to 6 addresses on 6 pipes, therefore each radio has a parent pipe and 5 child pipes, which are used to form a tree structure. Nodes communicate directly with their parent and children nodes. Any other traffic to or from a node must be routed through the network.</p>
<h1><a class="anchor" id="Topology"></a>
Topology of RF24Network</h1>
<p>Anybody who is familiar at all with IP networking should be able to easily understand <a class="el" href="classRF24Network.html">RF24Network</a> topology. The master node can be seen as the gateway, with up to 4 directly connected nodes. Each of those nodes creates a subnet below it, with up to 4 additional child nodes. The numbering scheme can also be related to IP addresses, for purposes of understanding the topology via subnetting. Nodes can have 5 children if multicast is disabled.</p>
<p>Expressing <a class="el" href="classRF24Network.html">RF24Network</a> addresses in IP format:</p>
<p>As an example, we could designate the master node in theory, as Address 10.10.10.10 <br  />
 The children nodes of the master would be 10.10.10.1, 10.10.10.2, 10.10.10.3, 10.10.10.4 and 10.10.10.5 <br  />
 The children nodes of 10.10.10.1 would be 10.10.1.1, 10.10.2.1, 10.10.3.1, 10.10.4.1 and 10.10.5.1 <br  />
</p>
<p>In <a class="el" href="classRF24Network.html">RF24Network</a>, the master is just 00 <br  />
 Children of master are 01,02,03,04,05 <br  />
 Children of 01 are 011,021,031,041,051 <br  />
</p>
<h1><a class="anchor" id="Network"></a>
Routing</h1>
<p>Routing of traffic is handled invisibly to the user, by the network layer. If the network addresses are assigned in accordance with the physical layout of the network, nodes will route traffic automatically as required. Users simply constuct a header containing the appropriate destination address, and the network will forward it through to the correct node. Individual nodes only route individual fragments, so if using fragmentation, routing nodes do not need it enabled, unless sending or receiving fragmented payloads themselves.</p>
<p>If routing data between parent and child nodes (marked by direct links on the topology image above) the network uses built-in acknowledgement and retry functions of the chip to prevent data loss. When payloads are sent to other nodes, they need to be routed. Routing is managed using a combination of built in ACK requests, and software driven network ACKs. This allows all routing nodes to forward data very quickly, with only the final routing node confirming delivery and sending back an acknowledgement.</p>
<p>Example: Node 00 sends to node 01. The nodes will use the built in auto-retry and auto-ack functions.<br  />
 Example: Node 00 sends to node 011. Node 00 will send to node 01 as before. Node 01 will forward the message to 011. If delivery was successful, node 01 will also forward a message back to node 00, indicating success.</p>
<p>Old Functionality: Node 00 sends to node 011 using auto-ack. Node 00 first sends to 01, 01 acknowledges. Node 01 forwards the payload to 011 using auto-ack. If the payload fails between 01 and 011, node 00 has no way of knowing.</p>
<dl class="section note"><dt>Note</dt><dd>When retrying failed payloads that have been routed, there is a chance of duplicate payloads if the network-ack is not successful. In this case, it is left up to the user to manage retries and filtering of duplicate payloads.</dd></dl>
<p>Acknowledgements can and should be managed by the application or user. If requesting a response from another node, an acknowledgement is not required, so a user defined type of 0-64 should be used, to prevent the network from responding with an acknowledgement. If not requesting a response, and wanting to know if the payload was successful or not, users can utilize header types 65-127.</p>
<h1><a class="anchor" id="TuningOverview"></a>
Tuning Overview</h1>
<p>The RF24 radio modules are generally only capable of either sending or receiving data at any given time, but have built-in auto-retry mechanisms to prevent the loss of data. These values are adjusted automatically by the library on startup, but can be further adjusted to reduce data loss, and thus increase throughput of the network. This page is intended to provide a general overview of its operation within the context of the network library, and provide guidance for adjusting these values.</p>
<h1><a class="anchor" id="RetryTiming"></a>
Auto-Retry Timing</h1>
<p>The core radio library provides the functionality of adjusting the internal auto-retry interval of the radio modules. In the network configuration, the radios can be set to automatically retry failed transmissions at intervals ranging anywhere from 500us (.5ms) up to 4000us (4ms). When operating any number of radios larger than two, it is important to stagger the assigned intervals, to prevent the radios from interfering with each other at the radio frequency (RF) layer.</p>
<p>The library should provide fairly good working values, as it simply staggers the assigned values within groups of radios in direct communication. This value can be set manually by calling radio.setRetries(X,15); and adjusting the value of X from 1 to 15 (steps of 250us).</p>
<h1><a class="anchor" id="AutoRetry"></a>
Auto-Retry Count and Extended Timeouts</h1>
<p>The core radio library also provides the ability to adjust the internal auto-retry count of the radio modules. The default setting is 15 automatic retries per payload, and can be extended by configuring the network.txTimeout variable. This default retry count should generally be left at 15, as per the example in the above section. An interval/retry setting of (15,15) will provide 15 retrys at intervals of 4ms, taking up to 60ms per payload. The library now provides staggered timeout periods by default, but they can also be adjusted on a per-node basis.</p>
<p>The txTimeout variable is used to extend the retry count to a defined duration in milliseconds. See the network.txTimeout variable. Timeout periods of extended duration (500+) will generally not help when payloads are failing due to data collisions, it will only extend the duration of the errors. Extended duration timeouts should generally only be configured on leaf nodes that do not receive data.</p>
<h1><a class="anchor" id="Examples"></a>
Examples</h1>
<p><b>Example 1:</b> Network with master node and three leaf nodes that send data to the master node. None of the leaf nodes need to receive data.</p>
<p>a: Master node uses default configuration<br  />
 b: Leaf nodes can be configured with extended timeout periods to ensure reception by the master.<br  />
 c: </p><div class="fragment"><div class="line">Leaf 01: network.txTimeout = 500;   Leaf 02: network.txTimeout = 573;  Leaf 03: network.txTimeout = 653;</div>
</div><!-- fragment --><p> This configuration will provide a reduction in errors, as the timeouts have been extended, and are staggered between devices.</p>
<p><b>Example 2:</b> Network with master node and three leaf nodes that send data to the master node. The second leaf node needs to receive configuration data from the master at set intervals of 1 second, and send data back to the master node. The other leaf nodes will send basic sensor information every few seconds, and a few dropped payloads will not affect the operation greatly.</p>
<p>a: Master node configured with extended timeouts of .5 seconds, and increased retry delay: </p><div class="fragment"><div class="line">radio.setRetries(11,15);</div>
<div class="line">network.txTimeout = 500;</div>
</div><!-- fragment --><p> b: Second leaf node configured with a similar timeout period and retry delay: </p><div class="fragment"><div class="line">radio.setRetries(8,15);</div>
<div class="line">network.txTimeout = 553;</div>
</div><!-- fragment --><p> c: First and third leaf nodes configured with default timeout periods or slightly increased timout periods. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 14 2020 07:42:45 for Newly Optimized RF24Network Layer by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
